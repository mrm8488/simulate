//================================================================================
//MIT License
//
//Copyright (c) 2018-2019 Mathieu Fehr and NathanaÃ«l Courant
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.
//
//1. Boost Software License - Version 1.0 - August 17th, 2003
//--------------------------------------------------------------------------------
//
//Copyright (c) 2006, 2007 Marcin Kalicinski
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//
//2. The MIT License
//--------------------------------------------------------------------------------
//
//Copyright (c) 2006, 2007 Marcin Kalicinski
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//of the Software, and to permit persons to whom the Software is furnished to do so,
//subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//IN THE SOFTWARE.
//
//================================================================================

#ifndef FAST_WFC_WAVE_HPP_
#define FAST_WFC_WAVE_HPP_

#include "utils/array2D.hpp"
#include <random>
#include <vector>

/**
 * Struct containing the values needed to compute the entropy of all the cells.
 * This struct is updated every time the wave is changed.
 * p'(pattern) is equal to patterns_frequencies[pattern] if wave.get(cell,
 * pattern) is set to true, otherwise 0.
 */
struct EntropyMemoisation {
  std::vector<double> plogp_sum; // The sum of p'(pattern) * log(p'(pattern)).
  std::vector<double> sum;       // The sum of p'(pattern).
  std::vector<double> log_sum;   // The log of sum.
  std::vector<unsigned> nb_patterns; // The number of patterns present
  std::vector<double> entropy;       // The entropy of the cell.
};

/**
 * Contains the pattern possibilities in every cell.
 * Also contains information about cell entropy.
 */
class Wave {
private:
  /**
   * The patterns frequencies p given to wfc.
   */
  const std::vector<double> patterns_frequencies;

  /**
   * The precomputation of p * log(p).
   */
  const std::vector<double> plogp_patterns_frequencies;

  /**
   * The precomputation of min (p * log(p)) / 2.
   * This is used to define the maximum value of the noise.
   */
  const double min_abs_half_plogp;

  /**
   * The memoisation of important values for the computation of entropy.
   */
  EntropyMemoisation memoisation;

  /**
   * This value is set to true if there is a contradiction in the wave (all
   * elements set to false in a cell).
   */
  bool is_impossible;

  /**
   * The number of distinct patterns.
   */
  const size_t nb_patterns;

  /**
   * The actual wave. data.get(index, pattern) is equal to 0 if the pattern can
   * be placed in the cell index.
   */
  Array2D<uint8_t> data;

public:
  /**
   * The size of the wave.
   */
  const unsigned width;
  const unsigned height;
  const unsigned size;

  /**
   * Initialize the wave with every cell being able to have every pattern.
   */
  Wave(unsigned height, unsigned width,
       const std::vector<double> &patterns_frequencies) noexcept;

  /**
   * Return true if pattern can be placed in cell index.
   */
  bool get(unsigned index, unsigned pattern) const noexcept {
    return data.get(index, pattern);
  }

  /**
   * Return true if pattern can be placed in cell (i,j)
   */
  bool get(unsigned i, unsigned j, unsigned pattern) const noexcept {
    return get(i * width + j, pattern);
  }

  /**
   * Set the value of pattern in cell index.
   */
  void set(unsigned index, unsigned pattern, bool value) noexcept;

  /**
   * Set the value of pattern in cell (i,j).
   */
  void set(unsigned i, unsigned j, unsigned pattern, bool value) noexcept {
    set(i * width + j, pattern, value);
  }

  /**
   * Return the index of the cell with lowest entropy different of 0.
   * If there is a contradiction in the wave, return -2.
   * If every cell is decided, return -1.
   */
  int get_min_entropy(std::minstd_rand &gen) const noexcept;

};

#endif // FAST_WFC_WAVE_HPP_
