//================================================================================
//MIT License
//
//Copyright (c) 2018-2019 Mathieu Fehr and NathanaÃ«l Courant
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//copies of the Software, and to permit persons to whom the Software is
//furnished to do so, subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//SOFTWARE.
//
//1. Boost Software License - Version 1.0 - August 17th, 2003
//--------------------------------------------------------------------------------
//
//Copyright (c) 2006, 2007 Marcin Kalicinski
//
//Permission is hereby granted, free of charge, to any person or organization
//obtaining a copy of the software and accompanying documentation covered by
//this license (the "Software") to use, reproduce, display, distribute,
//execute, and transmit the Software, and to prepare derivative works of the
//Software, and to permit third-parties to whom the Software is furnished to
//do so, all subject to the following:
//
//The copyright notices in the Software and this entire statement, including
//the above license grant, this restriction and the following disclaimer,
//must be included in all copies of the Software, in whole or in part, and
//all derivative works of the Software, unless such copies or derivative
//works are solely in the form of machine-executable object code generated by
//a source language processor.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//DEALINGS IN THE SOFTWARE.
//
//2. The MIT License
//--------------------------------------------------------------------------------
//
//Copyright (c) 2006, 2007 Marcin Kalicinski
//
//Permission is hereby granted, free of charge, to any person obtaining a copy
//of this software and associated documentation files (the "Software"), to deal
//in the Software without restriction, including without limitation the rights
//to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
//of the Software, and to permit persons to whom the Software is furnished to do so,
//subject to the following conditions:
//
//The above copyright notice and this permission notice shall be included in all
//copies or substantial portions of the Software.
//
//THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
//THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
//IN THE SOFTWARE.
//
//================================================================================

#include "propagator.hpp"
#include "wave.hpp"

void Propagator::init_compatible() noexcept {
  std::array<int, 4> value;
  // We compute the number of pattern compatible in all directions.
  for (unsigned y = 0; y < wave_height; y++) {
    for (unsigned x = 0; x < wave_width; x++) {
      for (unsigned pattern = 0; pattern < patterns_size; pattern++) {
        for (int direction = 0; direction < 4; direction++) {
          value[direction] =
            static_cast<unsigned>(propagator_state[pattern][get_opposite_direction(direction)]
                                  .size());
        }
        compatible.get(y, x, pattern) = value;
      }
    }
  }
}

void Propagator::propagate(Wave &wave) noexcept {

  // We propagate every element while there is element to propagate.
  while (propagating.size() != 0) {

    // The cell and pattern that has been set to false.
    unsigned y1, x1, pattern;
    std::tie(y1, x1, pattern) = propagating.back();
    propagating.pop_back();

    // We propagate the information in all 4 directions.
    for (unsigned direction = 0; direction < 4; direction++) {

      // We get the next cell in the direction direction.
      int dx = directions_x[direction];
      int dy = directions_y[direction];
      int x2, y2;
      if (periodic_output) {
        x2 = ((int)x1 + dx + (int)wave.width) % wave.width;
        y2 = ((int)y1 + dy + (int)wave.height) % wave.height;
      } else {
        x2 = x1 + dx;
        y2 = y1 + dy;
        if (x2 < 0 || x2 >= (int)wave.width) {
          continue;
        }
        if (y2 < 0 || y2 >= (int)wave.height) {
          continue;
        }
      }

      // The index of the second cell, and the patterns compatible
      unsigned i2 = x2 + y2 * wave.width;
      const std::vector<unsigned> &patterns =
        propagator_state[pattern][direction];

      // For every pattern that could be placed in that cell without being in
      // contradiction with pattern1
      for (auto it = patterns.begin(), it_end = patterns.end(); it < it_end;
           ++it) {

        // We decrease the number of compatible patterns in the opposite
        // direction If the pattern was discarded from the wave, the element
        // is still negative, which is not a problem
        std::array<int, 4> &value = compatible.get(y2, x2, *it);
        value[direction]--;

        // If the element was set to 0 with this operation, we need to remove
        // the pattern from the wave, and propagate the information
        if (value[direction] == 0) {
          add_to_propagator(y2, x2, *it);
          wave.set(i2, *it, false);
        }
      }
    }
  }
}
